;; All operations evaluate the RHS first, then the LHS. Errors in evaluation make
;; operations not commutative in the general case, so rules need to be manually
;; commuted.

(=> (add     (number $x) (number $y))  $(add     $x $y))
(=> (sub     (number $x) (number $y))  $(sub     $x $y))
(=> (mul     (number $x) (number $y))  $(mul     $x $y))
(=> (div     (number $x) (number $y))  $(div     $x $y))
(=> (mod     (number $x) (number $y))  $(mod     $x $y))
(=> (and     (number $x) (number $y))  $(and     $x $y))
(=> (or      (number $x) (number $y))  $(or      $x $y))
(=> (xor     (number $x) (number $y))  $(xor     $x $y))
(=> (andnot  (number $x) (number $y))  $(andnot  $x $y))
(=> (notand  (number $x) (number $y))  $(notand  $x $y))
(=> (nand    (number $x) (number $y))  $(nand    $x $y))
(=> (nor     (number $x) (number $y))  $(nor     $x $y))
(=> (xnor    (number $x) (number $y))  $(xnor    $x $y))
(=> (nandnot (number $x) (number $y))  $(nandnot $x $y))
(=> (nnotand (number $x) (number $y))  $(nnotand $x $y))

(=> (testbit  (number $x) $b)  $(testbit  $x $b))
(=> (ntestbit (number $x) $b)  $(ntestbit $x $b))

(=> (add     _ (error $e))  (error $e))
(=> (sub     _ (error $e))  (error $e))
(=> (mul     _ (error $e))  (error $e))
(=> (div     _ (error $e))  (error $e))
(=> (mod     _ (error $e))  (error $e))
(=> (and     _ (error $e))  (error $e))
(=> (or      _ (error $e))  (error $e))
(=> (xor     _ (error $e))  (error $e))
(=> (andnot  _ (error $e))  (error $e))
(=> (notand  _ (error $e))  (error $e))
(=> (nand    _ (error $e))  (error $e))
(=> (nor     _ (error $e))  (error $e))
(=> (xnor    _ (error $e))  (error $e))
(=> (nandnot _ (error $e))  (error $e))
(=> (nnotand _ (error $e))  (error $e))

(=> (add     (error $e) (number _))  $e)
(=> (sub     (error $e) (number _))  $e)
(=> (mul     (error $e) (number _))  $e)
(=> (and     (error $e) (number _))  $e)
(=> (or      (error $e) (number _))  $e)
(=> (xor     (error $e) (number _))  $e)
(=> (andnot  (error $e) (number _))  $e)
(=> (notand  (error $e) (number _))  $e)
(=> (nand    (error $e) (number _))  $e)
(=> (nor     (error $e) (number _))  $e)
(=> (xnor    (error $e) (number _))  $e)
(=> (nandnot (error $e) (number _))  $e)
(=> (nnotand (error $e) (number _))  $e)

(=> (when (div (error $e) (number $y))  (neq? $y 0))  $e)
(=> (when (mod (error $e) (number $y))  (neq? $y 0))  $e)
(=> (div _ 0)  (error DivModZero))
(=> (mod _ 0)  (error DivModZero))

(=> (shl      (error $e) _)  $e)
(=> (shr      (error $e) _)  $e)
(=> (testbit  (error $e) _)  $e)
(=> (ntestbit (error $e) _)  $e)
(=> (neg      (error $e) _)  $e)
(=> (popcnt   (error $e) _)  $e)

(=> (add (number $x) $y)  (add $y (number $x)))
(=> (mul (number $x) $y)  (mul $y (number $x)))
(=> (and (number $x) $y)  (and $y (number $x)))
(=> (or  (number $x) $y)  (or  $y (number $x)))
(=> (xor (number $x) $y)  (xor $y (number $x)))

(=> (add $x 0)   $x)
(=> (sub $x 0)   $x)
(=> (mul $x 1)   $x)
(=> (div $x 1)   $x)
(=> (and $x $x)  $x)
(=> (or  $x $x)  $x)

(=> (sub    $x $x)  (error_or $x 0))
(=> (mul    $x 0)   (error_or $x 0))
(=> (div    $x $x)  (error_or $x 1))
(=> (mod    $x $x)  (error_or $x 0))
(=> (mod    $x 1)   (error_or $x 0))
(=> (xor    $x $x)  (error_or $x 0))
(=> (andnot $x $x)  (error_or $x 0))

(=> (neg (neg $x))     $x)
(=> (sub 0 $y)         (neg $y))
(=> (add $x (neg $y))  (sub $x $y))
(=> (sub $x (neg $y))  (add $x $y))
(=> (add (neg $x) $y)  (sub $y (error_or $y $x)))

(=> (mod $x 2)  (testbit $x 0))
(=> (and $x 1)  (testbit $x 0))

(=> (sub 1 (testbit  $x $b))  (ntestbit $x $b))
(=> (sub 1 (ntestbit $x $b))  (testbit  $x $b))

(=> (testbit  (testbit  $x $b) 0)  (testbit  $x $b))
(=> (testbit  (ntestbit $x $b) 0)  (ntestbit $x $b))
(=> (ntestbit (testbit  $x $b) 0)  (ntestbit $x $b))
(=> (ntestbit (ntestbit $x $b) 0)  (testbit  $x $b))

(=> (ntestbit (and     $x $y) $b)
    (testbit  (nand    $x $y) $b))
(=> (ntestbit (or      $x $y) $b)
    (testbit  (nor     $x $y) $b))
(=> (ntestbit (xor     $x $y) $b)
    (testbit  (xnor    $x $y) $b))
(=> (ntestbit (andnot  $x $y) $b)
    (testbit  (nandnot $x $y) $b))
(=> (ntestbit (notand  $x $y) $b)
    (testbit  (nnotand $x $y) $b))
(=> (ntestbit (nand    $x $y) $b)
    (testbit  (and     $x $y) $b))
(=> (ntestbit (nor     $x $y) $b)
    (testbit  (or      $x $y) $b))
(=> (ntestbit (xnor    $x $y) $b)
    (testbit  (xor     $x $y) $b))
(=> (ntestbit (nandnot $x $y) $b)
    (testbit  (andnot  $x $y) $b))
(=> (ntestbit (nnotand $x $y) $b)
    (testbit  (notand  $x $y) $b))

(=> (testbit  (shr $x $b) 0)  (testbit  $x $b))
(=> (ntestbit (shr $x $b) 0)  (ntestbit $x $b))
(=> (shl (testbit $x $b) $b)  (and $x (shl 1 $b)))

;; Shifts
(=> (mul $x (number $y : pow2 $b))  (shl $x $b))
(=> (div $x (number $y : pow2 $b))  (shr $x $b))

;; Single-bit AND
;; x * y => x & y
(=> (mul (testbit $x $b) (testbit $y $b))
    (testbit (and $x $y) $b))

;; Single-bit AND
;; (x + y) / 2 => x & y
(=> (div (add (testbit $x $b) (testbit $y $b)) 2)
    (testbit (and $x $y) $b))

;; Single-bit OR
;; (x + y) - (x & y) = x | y, commuted and associated
(=> (sub (add (testbit $x $b) (testbit $y $b))
         (and (testbit $x $b) (testbit $y $b)))
    (testbit (or $x $y) $b))
(=> (sub (add (testbit $x $b) (testbit $y $b))
         (and (testbit $y $b) (testbit $x $b)))
    (testbit (or $y $x) $b))
(=> (add (testbit $x $b)
         (sub (testbit $y $b)
              (and (testbit $x $b) (testbit $y $b))))
    (testbit (or $x $y) $b))
(=> (add (testbit $x $b)
         (sub (testbit $y $b)
              (and (testbit $y $b) (testbit $x $b))))
    (testbit (or $y $x) $b))
(=> (add (sub (testbit $y $b)
              (and (testbit $x $b) (testbit $y $b)))
         (testbit $x $b))
    (testbit (or $y $x) $b))
(=> (add (sub (testbit $y $b)
              (and (testbit $y $b) (testbit $x $b)))
         (testbit $x $b))
    (testbit (or $x $y) $b))

;; Single-bit XOR
;; (x + y) % 2 => x ^ y
(=> (mod (add (testbit $x $b) (testbit $y $b)) 2)
    (testbit (xor $x $y) $b))

;; Single-bit XOR
;; (x + y) * !(x & y) => x ^ y, commuted
(=> (mul (add (testbit $x $b) (testbit $y $b))
         (testbit (nand $x $y) $b)))
    (testbit (xor $x $y) $b))
(=> (mul (add (testbit $x $b) (testbit $y $b))
         (testbit (nand $y $x) $b))
    (testbit (xor $y $x) $b))
(=> (mul (testbit (nand $x $y) $b))
         (add (testbit $x $b) (testbit $y $b)))
    (testbit (xor $x $y) $b))
(=> (mul (testbit (nand $x $y) $b))
         (add (testbit $y $b) (testbit $x $b)))
    (testbit (xor $y $x) $b))

;; Single-bit XOR
;; (x + y) & !(x & y) => x ^ y, commuted
(=> (and (add (testbit $x $b) (testbit $y $b))
         (testbit (nand $x $y) $b))
    (testbit (xor $x $y) $b))
(=> (and (add (testbit $x $b) (testbit $y $b))
         (testbit (nand $y $x) $b))
    (testbit (xor $y $x) $b))
(=> (and (testbit (nand $x $y) $b))
         (add (testbit $x $b) (testbit $y $b)))
    (testbit (xor $x $y) $b))
(=> (and (testbit (nand $x $y) $b))
         (add (testbit $y $b) (testbit $x $b)))
    (testbit (xor $y $x) $b))

;; XOR
;; (x | y) & !(x & y) => x ^ y, commuted
(=> (and (or $x $y) (nand $x $y))
    (xor $x $y))
(=> (and (or $x $y) (nand $y $x))
    (xor $y $x)))
(=> (and (nand $x $y) (or $x $y))
    (xor $x $y)))
(=> (and (nand $x $y) (or $y $x))
    (xor $y $x)))

;; Single-bit ANDNOT
;; x * !y => x & !y
(=> (mul (testbit $x $b) (ntestbit $y $b))
    (testbit (andnot $x $y) $b))

;; Single-bit NOTAND
;; !x * y => !x & y
(=> (mul (ntestbit $x $b) (testbit $y $b))
    (testbit (notand $x $y) $b))

;; Single-bit NOR
;; !x * !y => !x & !y => !(x | $y)
(mul (ntestbit $x $b) (ntestbit $y $b)) => (testbit (nor $x $y) $b)

;; Single-bit distribution
(=> (and      (testbit  $x $b) (testbit  $x $b))  (testbit  (and     $x $y) $b)
(=> (or       (testbit  $x $b) (testbit  $x $b))  (testbit  (or      $x $y) $b)
(=> (xor      (testbit  $x $b) (testbit  $x $b))  (testbit  (xor     $x $y) $b)
(=> (andnot   (testbit  $x $b) (testbit  $x $b))  (testbit  (andnot  $x $y) $b)
(=> (notand   (testbit  $x $b) (testbit  $x $b))  (testbit  (notand  $x $y) $b)
(=> (nand     (testbit  $x $b) (testbit  $x $b))  (testbit  (nand    $x $y) $b)
(=> (nor      (testbit  $x $b) (testbit  $x $b))  (testbit  (nor     $x $y) $b)
(=> (xnor     (testbit  $x $b) (testbit  $x $b))  (testbit  (xnor    $x $y) $b)
(=> (nandnot  (testbit  $x $b) (testbit  $x $b))  (testbit  (nandnot $x $y) $b)
(=> (nnotand  (testbit  $x $b) (testbit  $x $b))  (testbit  (nnotand $x $y) $b)
(=> (and      (ntestbit $x $b) (ntestbit $x $b))  (ntestbit (and     $x $y) $b)
(=> (or       (ntestbit $x $b) (ntestbit $x $b))  (ntestbit (or      $x $y) $b)
(=> (xor      (ntestbit $x $b) (ntestbit $x $b))  (ntestbit (xor     $x $y) $b)
(=> (andnot   (ntestbit $x $b) (ntestbit $x $b))  (ntestbit (andnot  $x $y) $b)
(=> (notand   (ntestbit $x $b) (ntestbit $x $b))  (ntestbit (notand  $x $y) $b)
(=> (nand     (ntestbit $x $b) (ntestbit $x $b))  (ntestbit (nand    $x $y) $b)
(=> (nor      (ntestbit $x $b) (ntestbit $x $b))  (ntestbit (nor     $x $y) $b)
(=> (xnor     (ntestbit $x $b) (ntestbit $x $b))  (ntestbit (xnor    $x $y) $b)
(=> (nandnot  (ntestbit $x $b) (ntestbit $x $b))  (ntestbit (nandnot $x $y) $b)
(=> (nnotand  (ntestbit $x $b) (ntestbit $x $b))  (ntestbit (nnotand $x $y) $b)

;; Multi-bit AND
(=> (where (mod $x (number $y))
           (is-power-of-two $y))
    (and $x (sub $y 1)))
(=> (where (add (and $x (number $m)) (and $x (number $n)))
           (eq? (and $m $n) 0))
    (and $x (or $m $n)))
(=> (where (add (testbit $x 0) (and $x (number $m)))
           (eq? (testbit $m 0) 0))
    (and $x (or $m 1)))
(=> (where (add (and $x (number $m)) (testbit $x 0))
           (eq? (testbit $m 0) 0))
    (and $x (or $m 1)))
(=> (or (testbit $x 0) (and $x (number $m)))
    (and $x (or $m 1)))
(=> (or (and $x (number $m)) (testbit $x 0))
    (and $x (or $m 1)))

;; Popcnt
(=> (where (add (testbit $x $b1) (testbit $x $b2))
           (not (eq? $b1 $b2)))
    (popcnt (and $x (or (lsh 1 $b1) (lsh 1 $b2))))
(=> (where (add (popcnt (and $x (number $m))) (testbit $x $b))
           (eq? (testbit $m $b) 0))
    (popcnt (and $x (or $m (lsh 1 $b)))))
(=> (where (add (testbit $x $b) (popcnt (and $x (number $m))))
           (eq? (testbit $m $b) 0))
    (popcnt (and $x (or $m (lsh 1 $b)))))
(=> (where (add (popcnt (and $x (number $m))) (popcnt (and $x (number $n))))
           (eq? (and $m $n) 0))
    (popcnt (and $x (or $m $n))))
(=> (or (testbit $x $b1) (testbit $x $b2))
    (popcnt (and $x (or $(lsh 1 $b1) $(lsh 1 $b2))))
(=> (or (popcnt (and $x (number $m))) (testbit $x $b))
    (popcnt (and $x (or $m $(lsh 1 $b)))))
(=> (or (testbit $x $b) (popcnt (and $x (number $m))))
    (popcnt (and $x (or $m $(lsh 1 $b)))))
(=> (or (popcnt (and $x (number $m))) (popcnt (and $x (number $n))))
    (popcnt (and $x (or $m $n))))
